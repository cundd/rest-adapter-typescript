import 'reflect-metadata';
import { ClassConstructorType } from '../ClassConstructorType';
import { isPrimitiveTypeEnum, PrimitiveTypeEnum, typeForTypeName } from './PrimitiveTypeEnum';
import { metadataKey, PropertyTypeDefinition } from './PropertyTypeDefinition';

// type RaPropertyAttributes<T> = ClassConstructorType<T> | string | number | undefined;
type RaPropertyReturn = <P extends object>(target: P, propertyKey: string) => void;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property(Address, PropertyTypeOptions.Lazy, 'address')
 *          _address: Address
 *      }
 *  ```
 * @param {ClassConstructorType<T>} type Convert the input value into an instance of this Constructor
 * @param {PropertyTypeOptions} options
 * @param {string} rename Use this key instead of the property key when converting
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    type: ClassConstructorType<T>,
    options: PropertyTypeOptions,
    rename: string
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property(Address, PropertyTypeOptions.Lazy)
 *          _address: Address
 *      }
 *  ```
 * @param {ClassConstructorType<T>} type Convert the input value into an instance of this Constructor
 * @param {PropertyTypeOptions} options
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    type: ClassConstructorType<T>,
    options: PropertyTypeOptions
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property(Address, 'address')
 *          _address: Address
 *      }
 *  ```
 * @param {ClassConstructorType<T>} type Convert the input value into an instance of this Constructor
 * @param {string} rename Use this key instead of the property key when converting
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    type: ClassConstructorType<T>,
    rename: string
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property('street', PropertyTypeOptions.Lazy)
 *          _street: string
 *      }
 *  ```
 * @param {string} rename Use this key instead of the property key when converting
 * @param {PropertyTypeOptions} options
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    rename: string,
    options: PropertyTypeOptions
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property('street')
 *          _street: string
 *      }
 *  ```
 * @param {string} rename Use this key instead of the property key when converting
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    rename: string
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property(Address)
 *          address: Address
 *      }
 *  ```
 * @param {ClassConstructorType<T>} type Convert the input value into an instance of this Constructor
 * @return {RaPropertyReturn}
 */
export function ra_property<T>(
    type: ClassConstructorType<T>
): RaPropertyReturn;

/**
 * Example:
 *
 *  ```
 *      export class Model {
 *          @ra_property()
 *      }
 *  ```
 * @return {RaPropertyReturn}
 */
export function ra_property(): RaPropertyReturn;

export function ra_property<T>(...args: any[]) {
    return <P extends object>(target: P, propertyKey: string): void => {
        let type: ClassConstructorType<T> | PrimitiveTypeEnum | undefined;
        let rename: string | undefined;
        let options: number = PropertyTypeOptions.None;
        for (const arg of args) {
            if (typeof arg === 'string') {
                rename = arg;
            } else if (typeof arg === 'function') {
                type = arg;
            } else if (typeof arg === 'number') {
                options = arg;
            }
        }

        // If no explicit type was given check the Meta Data generated by TypeScript
        if (type === undefined) {
            const systemMetaData = Reflect.getMetadata('design:type', target, propertyKey);
            if (systemMetaData) {
                type = typeForTypeName(systemMetaData.name) || systemMetaData;
            } else {
                type = undefined;
            }
        } else if (!isPrimitiveTypeEnum(type)) {
            // Check if the Class name belongs to a primitive class (e.g. `String`, `Number`)
            type = typeForTypeName(type.name) || type;
        }

        const propertyTypeDefinition = new PropertyTypeDefinition(type, options, propertyKey, rename);
        Reflect.defineMetadata(
            metadataKey,
            propertyTypeDefinition,
            target,
            propertyKey
        );

        // If `rename` is given, also register the metadata for it
        if (rename) {
            Reflect.defineMetadata(
                metadataKey,
                propertyTypeDefinition,
                target,
                rename
            );
        }
    };
}

export enum PropertyTypeOptions {
    None = 0b00000,
    Multiple = 0b00001,
    NoSerialization = 0b00100,
    Lazy = 0b00010, // Not implemented yet
}
